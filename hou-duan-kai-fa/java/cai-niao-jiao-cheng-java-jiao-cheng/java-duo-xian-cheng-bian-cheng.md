# Java 多线程编程

Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。

这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。

### 线程的生命周期![](/assets/线程生命周期.png)

* 新建状态
  使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start\(\) 这个线程。
* 就绪状态
  当线程对象调用了 start\(\) 方法后，线程进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。
* 运行状态
  就绪状态的线程获取 CPU 资源，就可以执行 run\(\)，此时线程便处于运行状态。处于运行状态的线程最为复杂，他可以变为阻塞状态、就绪状态和死亡状态。
* 阻塞状态
  线程执行 sleep、suspend 等方法，失去所占用资源后，该线程就从运行状态进入阻塞状态。
  在睡眠时间已到或获得设备资源后可以重新进入就绪状态。分为三种：
  * 等待阻塞：运行状态中的线程执行 wait\(\) 方法，使线程进入到等待阻塞状态。

  * 同步阻塞：线程在获取 synchronized 同步锁失败\(因为同步锁被其他线程占用\)。

  * 其他阻塞：通过调用线程的 sleep\(\) 或 join\(\) 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep\(\) 状态超时，join\(\) 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
* 死亡状态
  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 线程的优先级

范围：1 （Thread.MIN\_PRIORITY ） - 10 （Thread.MAX\_PRIORITY ）

默认优先级：NORM\_PRIORITY（5）

### 创建线程

* 通过实现 Runnable 接口；
* 通过继承 Thread 类本身；
* 通过 Callable 和 Future 创建线程。

### 通过实现 Runnable 接口来创建线程

### 通过继承Thread来创建线程

### 通过 Callable 和 Future 创建线程

1. 创建 Callable 接口的实现类，并实现 call\(\) 方法，该 call\(\) 方法将作为线程执行体，并且有返回值。

2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call\(\) 方法的返回值。

3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。

4. 调用 FutureTask 对象的 get\(\) 方法来获得子线程执行结束后的返回值。

### 创建线程的三种方式的对比

1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。

2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread\(\) 方法，直接使用 this 即可获得当前线程。

### 线程的几个主要概念

* 线程同步
* 线程间通信
* 线程死锁
* 线程控制：挂起、停止和恢复

### 多线程的使用



