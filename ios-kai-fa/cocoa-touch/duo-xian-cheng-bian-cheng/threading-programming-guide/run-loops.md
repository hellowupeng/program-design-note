# Run Loops

运行循环是与线程相关的基础架构的一部分。运行循环是一个事件处理循环，用于安排工作并协调接收到的事件。运行循环的目的是在有任务要做时让线程忙碌，并在没有任务时让线程进入睡眠状态。

运行循环管理不是完全自动的。您仍然必须设计您的线程代码以在适当的时间启动运行循环并响应传入的事件。Cocoa 和 Core Foundation 都提供运行循环对象，以帮助您配置和管理线程的运行循环。您的应用程序不需要明确创建这些对象;每个线程（包括应用程序的主线程）都有一个关联的运行循环对象。但是，只有次要线程需要显式运行其运行循环。应用程序框架自动设置并在主线程上运行运行循环，作为应用程序启动过程的一部分。

### 运行循环的解剖

运行循环非常类似于它的名字。它是一个循环，您的线程输入并用它来运行事件处理程序以响应传入事件。您的代码提供了用于实现运行循环的实际循环部分的控制语句 - 换句话说，您的代码提供了驱动运行循环的 while 或 for 循环。在循环中，使用运行循环对象来“运行”接收事件并调用已安装的处理程序的事件处理代码。

运行循环接收来自两种不同类型源的事件。输入源传递异步事件，通常是来自另一个线程或来自不同应用程序的消息。计时器源提供同步事件，发生在计划时间或重复间隔。这两种类型的源都使用特定于应用程序的处理程序来处理事件到达时的状态。

下图显示了运行循环和各种来源的概念结构。输入源将异步事件传递给相应的处理程序，并导致`runUntilDate：`方法（在线程的关联`NSRunLoop`对象上调用）退出。计时器源将事件传递到其处理程序例程，但不会导致运行循环退出。

运行循环的结构及其来源：

![](/assets/runloop.jpg)

除了处理输入源之外，运行循环还会生成有关运行循环行为的通知。已注册的运行循环观察程序可以接收这些通知并使用它们对线程执行附加处理。您可以使用 Core Foundation 在线程上安装运行循环观察器。

##### 运行循环模式

运行循环模式是要监视的输入源和定时器的集合，以及要通知的运行循环观察器的集合。每次运行运行循环时，都需要明确或隐式地指定要运行的特定“模式”。在运行循环的过程中，只监视与该模式相关的源并允许其发送事件。同样，只有与该模式相关的观察者才会收到运行循环进度的通知。与其他模式相关的源保持任何新事件，直到随后以适当的模式通过循环。

在你的代码中，你可以通过名字来识别模式。 Cocoa 和 Core Foundation 都定义了一个默认模式和几种常用模式，以及用于在代码中指定这些模式的字符串。您可以通过为模式名称指定自定义字符串来定义自定义模式。虽然分配给自定义模式的名称是任意的，但这些模式的内容却不是。您必须确保将一个或多个输入源，定时器或运行循环观察器添加到您创建的任何模式中，以便它们有用。

您可以使用模式在特定的运行循环中过滤掉不需要的源中的事件。大多数情况下，您需要在系统定义的“默认”模式下运行您的运行循环。但是，模态面板可能会以“模态”模式运行。在此模式下，只有与模态面板相关的源才会将事件传递给线程。对于辅助线程，您可以使用自定义模式来防止低优先级的源在时间关键型操作期间传递事件。

> 注意：模式根据事件的来源进行区分，而不是事件的类型。例如，您不会使用模式来仅匹配鼠标按下事件或仅匹配键盘事件。您可以使用模式来侦听不同的端口集，暂时暂停定时器，或者更改当前正在监视的源和运行循环观察器。

预定义的运行循环模式：

* 默认（Default）

[`NSDefaultRunLoopMode`](https://developer.apple.com/documentation/foundation/runloopmode/1409732-defaultrunloopmode)\(Cocoa\)

[`kCFRunLoopDefaultMode`](https://developer.apple.com/documentation/corefoundation/kcfrunloopdefaultmode)\(Core Foundation\)

默认模式是用于大多数操作的模式。大多数情况下，您应该使用此模式启动运行循环并配置输入源。

* 连接（Connection）

[`NSConnectionReplyMode`](https://developer.apple.com/documentation/foundation/nsconnectionreplymode)\(Cocoa\)

Cocoa将此模式与NSConnection对象一起使用来监视回复。你应该很少需要自己使用这种模式。

* Modal

[`NSModalPanelRunLoopMode`](https://developer.apple.com/documentation/appkit/nsmodalpanelrunloopmode)\(Cocoa\)

Cocoa 使用这种模式来识别用于模态面板的事件。

* 事件跟踪（Event tracking）

[`NSEventTrackingRunLoopMode`](https://developer.apple.com/documentation/foundation/runloopmode/1428765-eventtrackingrunloopmode)\(Cocoa\)

Cocoa使用这种模式来限制鼠标拖拽循环和其他类型的用户界面追踪循环中的传入事件。

* 通用模式（Common modes）

[`NSRunLoopCommonModes`](https://developer.apple.com/documentation/foundation/nsrunloopcommonmodes)\(Cocoa\)

[`kCFRunLoopCommonModes`](https://developer.apple.com/documentation/corefoundation/cfrunloopmode/1542364-commonmodes)\(Core Foundation\)

这是一个可配置的常用模式组。将输入源与此模式关联也会将其与组中的每个模式相关联。对于Cocoa应用程序，默认情况下，此集合包含默认，模式和事件跟踪模式。Core Foundation 最初只包含默认模式。您可以使用`CFRunLoopAddCommonMode` 函数将自定义模式添加到该集合。

##### 输入源

输入源以异步方式向您的线程传递事件。事件的来源取决于输入源的类型，输入源通常是两类中的一类。基于端口的输入源监视你的应用程序的 Mach 端口。自定义输入源监视自定义事件源。就您的运行循环而言，输入源是基于端口还是自定义应该没有关系。系统通常实现两种类型的输入源，您可以按原样使用它们。两个来源之间的唯一区别是它们如何发出信号。基于端口的源由内核自动发出信号，自定义源必须从另一个线程手动发送信号。

创建输入源时，可以将其分配给运行循环的一个或多个模式。模式会影响在任何特定时刻监视哪些输入源。大多数情况下，您在默认模式下运行循环，但您也可以指定自定义模式。如果输入源不处于当前监控的模式，则会生成其生成的所有事件，直到运行循环以正确的模式运行。

###### 基于端口的来源

Cocoa和Core Foundation为使用与端口相关的对象和函数创建基于端口的输入源提供了内置的支持。例如，在Cocoa中，您根本不需要直接创建输入源。您只需创建一个端口对象并使用NSPort的方法将该端口添加到运行循环。port对象为您处理所需输入源的创建和配置。

在Core Foundation中，您必须手动创建端口及其运行循环源。在这两种情况下，都使用与端口不透明类型（CFMachPortRef，CFMessagePortRef或CFSocketRef）关联的函数来创建适当的对象。

###### 自定义输入源

要创建自定义输入源，您必须使用与Core Foundation中的CFRunLoopSourceRef opaque类型关联的函数。您可以使用多个回调函数来配置自定义输入源。Core Foundation在不同的点调用这些函数来配置源代码，处理所有传入的事件，并在源代码从运行循环中移除时拆除源代码。

除了在事件到达时定义自定义源的行为之外，还必须定义事件传递机制。这部分源代码在单独的线程上运行，负责为输入源提供数据，并在数据准备好处理时用信号通知它。事件传递机制取决于你，但不必过于复杂。

###### Cocoa 执行选择器来源

除了基于端口的源代码之外，Cocoa还定义了一个自定义输入源，允许您在任何线程上执行选择器。与基于端口的源一样，执行选择器请求在目标线程上被序列化，从而减轻了在一个线程上运行多个方法时可能发生的许多同步问题。与基于端口的源不同，执行选择器源在执行其选择器后从运行循环中移除。

在另一个线程上执行选择器时，目标线程必须具有活动的运行循环。对于你创建的线程，这意味着等待你的代码明确地启动运行循环。但是，因为主线程启动自己的运行循环，只要应用程序调用应用程序委托的`applicationDidFinishLaunching`：方法，就可以开始在该线程上发出调用。运行循环每次通过循环处理所有排队的执行选择器调用，而不是在每次循环迭代期间处理一个。

在其他线程上执行选择器：



##### 定时器来源

##### 运行循环观察者

##### 事件的运行循环序列

### 何时使用运行循环？

### 使用运行循环对象

### 配置运行循环源

###  

  
  


  




