# 同步

应用程序中存在多个线程会导致潜在的问题，这些问题可能会导致从多个执行线程安全访问资源。修改相同资源的两个线程可能会以非预期的方式相互干扰。例如，一个线程可能会覆盖另一个线程的更改，或者将应用程序置于未知且可能无效的状态。如果幸运的话，损坏的资源可能会导致明显的性能问题或崩溃，这些问题相对容易追踪和修复。然而，如果你不幸运，腐败可能会导致微妙的错误，直到很久以后才会出现，或者错误可能需要对基础编码假设进行重大改革。

说到线程安全性，一个好的设计就是最好的保护。避免共享资源并尽量减少线程之间的交互使得线程不太可能互相干扰。然而，完全无干扰的设计并不总是可行的。在你的线程必须交互的情况下，你需要使用同步工具来确保当他们交互时，他们可以安全地执行。

OS X和iOS提供了许多同步工具供您使用，包括提供互斥访问的工具，以及在应用程序中正确排序事件的工具。

### 同步工具

为防止不同线程意外更改数据，可以设计应用程序以避免同步问题，也可以使用同步工具。尽管完全避免同步问题是可取的，但并非总是可行。

##### 原子操作

原子操作是一种简单的同步形式，适用于简单的数据类型。原子操作的优点是它们不会阻塞竞争线程。对于简单的操作，例如增加一个计数器变量，这可能会导致比锁定更好的性能。

OS X和iOS包含许多操作，以便对32位和64位值执行基本的数学和逻辑运算。这些操作包括比较和交换，测试和设置以及测试和清除操作的原子版本。有关受支持的原子操作的列表，请参阅 /usr/include/libkern/OSAtomic.h 头文件或查看原子手册页。

##### 内存障碍和挥发性变量

为了达到最佳性能，编译器通常会对汇编级指令进行重新排序，以尽可能保持处理器的指令流水线。作为这种优化的一部分，编译器可能会重新排序访问主内存的指令，因为它认为这样做不会产生不正确的数据。不幸的是，编译器并不总是能够检测到所有依赖于内存的操作。如果看似单独的变量实际上相互影响，编译器优化可能会以错误的顺序更新这些变量，从而产生潜在的错误结果。

内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序进行。内存屏障就像栅栏一样，强制处理器完成位于栅栏前的任何加载和存储操作，然后才允许其执行位于栅栏后的加载和存储操作。内存屏障通常用于确保一个线程（但对另一个线程可见）的内存操作始终按预期顺序进行。在这种情况下缺乏内存屏障可能会让其他线程看到看似不可能的结果。

易变变量将另一种类型的记忆约束应用于单个变量。编译器通常通过将变量的值加载到寄存器中来优化代码。对于局部变量，这通常不是问题。如果变量从另一个线程可见，但是这样的优化可能会阻止其他线程注意到它的任何更改。将`volatile`关键字应用于变量会强制编译器在每次使用时从内存加载该变量。如果可以随时通过编译器可能无法检测到的外部源更改其值，则可以将变量声明为`volatile`。

因为内存屏障和`volatile`变量都会减少编译器可以执行的优化次数，所以应该谨慎使用它们，并且只在需要时才能保证正确性。

##### 锁

锁是最常用的同步工具之一。您可以使用锁来保护代码的关键部分，这是一段代码，一次只允许一个线程访问。例如，关键部分可能会操纵特定的数据结构或使用一次最多支持一个客户端的资源。通过在本节中放置一个锁，可以排除其他线程进行可能影响代码正确性的更改。

锁类型:

* 互斥锁（Mutex）

互斥（或互斥锁）作为资源周围的保护屏障。互斥锁是一种信号量，一次只允许访问一个线程。如果一个互斥体正在使用，而另一个线程试图获取它，则该线程将阻塞，直到互斥体被其原始持有者释放。如果多个线程竞争相同的互斥量，则一次只允许一个线程访问它。

* 递归锁（Recursive lock）

递归锁是互斥锁的变体。递归锁允许单个线程在释放之前多次获取锁。其他线程会一直处于阻塞状态，直到锁的所有者释放该锁的次数与获取它的次数相同。递归锁主要在递归迭代期间使用，但也可能在多个方法需要分别获取锁的情况下使用。

* 读写锁（Read-write lock）

读写锁也被称为共享排他锁。这种类型的锁通常用于较大规模的操作，并且如果经常读取受保护的数据结构并仅偶尔进行修改，则可显着提高性能。在正常操作期间，多个阅读器可以同时访问数据结构。然而，当一个线程想要写入该结构时，它会阻塞，直到所有的读取器释放该锁，此时它获得锁并可以更新该结构。写入线程正在等待锁定时，新的读取器线程将阻塞，直到写入线程完成。系统仅支持使用POSIX线程的读写锁定。

* 分布式锁（Distributed lock）

分布式锁在进程级别提供互斥访问。与真正的互斥锁不同，分布式锁不会阻止进程或阻止进程运行。它只是报告锁何时忙，并让流程决定如何继续。

* 旋转锁（Spin lock）

自旋锁反复轮询其锁定条件，直到该条件成立。自旋锁最常用于预计等待锁定时间较短的多处理器系统。在这些情况下，轮询通常比阻塞线程更有效，这涉及上下文切换和线程数据结构的更新。由于轮询性质，系统不提供自旋锁的任何实现，但是您可以在特定情况下轻松实现它们。

* 双重检查锁（Double-checked lock）

双重检查锁试图通过在锁定之前测试锁定标准来降低获取锁的开销。由于双重检查的锁可能不安全，系统不提供对它们的明确支持，因此不鼓励使用它们。

> 注意：大多数类型的锁还包含内存屏障，以确保在进入临界区之前完成任何前面的加载和存储指令。

##### 条件

条件是另一种类型的信号量，它允许线程在特定条件为真时互相发信号。条件通常用于指示资源的可用性或确保任务按特定顺序执行。当一个线程测试一个条件时，它会阻塞，除非该条件已经成立。直到其他线程明确更改并发出信号，它才会被阻塞。条件和互斥锁之间的区别在于可能允许多个线程同时访问条件。这种情况更多的是一个看门人，它根据一些特定的标准让不同的线程通过门。

您可能会使用某种条件的一种方法是管理一系列未决事件。当队列中有事件时，事件队列将使用条件变量来通知等待线程。如果有一个事件到达，队列会适当地发出信号。如果一个线程已经在等待，它会被唤醒，然后它将把队列从队列中拉出来并处理它。如果两个事件大致同时进入队列，则队列将两次通知状况以唤醒两个线程。

##### 执行选择器例程（Routine）

Cocoa 应用程序有一种方便的方式将消息以同步方式传递给单个线程。NSObject类声明了在应用程序的一个活动线程上执行选择器的方法。这些方法允许线程异步传递消息，并保证它们将由目标线程同步执行。例如，可以使用执行选择器消息将分布式计算的结果传递到应用程序的主线程或指定的协调器线程。执行选择器的每个请求都在目标线程的运行循环中排队，然后按接收到的顺序按顺序处理请求。

### 同步开销和性能

### 线程安全和信号

### 线程安全设计提示

### 使用原子操作

### 使用锁

### 使用条件





