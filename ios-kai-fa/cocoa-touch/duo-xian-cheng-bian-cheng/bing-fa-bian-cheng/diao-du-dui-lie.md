# 调度队列（Dispatch Queues）

Grand Central Dispatch（GCD）调度队列是执行任务的强大工具。调度队列让你可以与调用者异步或同步地执行任意代码块。您可以使用调度队列来执行几乎所有用于在单独的线程上执行的任务。调度队列的优点是它们比相应的线程代码更简单，更有效地执行这些任务。

#### 关于调度队列

调度队列是一种在应用程序中异步执行任务的简单方法。任务只是您的应用程序需要执行的一些工作。例如，您可以定义一个任务来执行一些计算，创建或修改数据结构，处理从文件读取的某些数据或任何数量的事物。您可以通过将相应的代码放入函数或块对象中并将其添加到调度队列来定义任务。

调度队列是一个类似于对象的结构，用于管理您向其提交的任务。所有的调度队列都是先进先出的数据结构。因此，添加到队列中的任务始终以与添加队列相同的顺序开始。GCD会自动为您提供一些调度队列，但您可以为特定目的创建其他调度队列。

调度队列的类型：

* Serial（串行）

串行队列（也称为私有调度队列）按照它们被添加到队列中的顺序每次执行一个任务。当前正在执行的任务运行在由调度队列管理的不同线程上（可能因任务而异）。串行队列通常用于同步对特定资源的访问。

您可以根据需要创建尽可能多的串行队列，并且每个队列都可以与所有其他队列同时运行。换句话说，如果你创建了四个串行队列，每个队列一次只执行一个任务，但最多可以同时执行四个任务，每个队列一个。

* Concurrent（并行）

并发队列（也称为全局调度队列）同时执行一个或多个任务，但任务仍按其添加到队列中的顺序启动。当前正在执行的任务在由调度队列管理的不同线程上运行。在任何给定点执行的任务的确切数量是可变的，并取决于系统条件。

在 iOS 5 以后的版本，您可以通过将 DISPATCH\_QUEUE\_CONCURRENT 指定为队列类型来自己创建并发调度队列。另外，还有四个预定义的全局并发队列供您的应用程序使用。

* Main dispatch queue（主调度队列）

主调度队列是一个全局可用的串行队列，用于执行应用程序主线程上的任务。该队列与应用程序的运行循环（如果存在的话）一起工作，以将排队任务的执行与附加到运行循环的其他事件源的执行交错​​。因为它运行在应用程序的主线程上，所以主队列通常用作应用程序的关键同步点。虽然您不需要创建主调度队列，但您确实需要确保您的应用程序正确排除它。

当向应用程序添加并发时，调度队列相对于线程提供了几个优点。最直接的优点是工作队列编程模型的简单性。使用线程，您必须为您要执行的工作以及创建和管理线程本身编写代码。调度队列让您专注于您实际想要执行的工作，而无需担心线程创建和管理。相反，系统会为您处理所有的线程创建和管理。他的优势在于系统能够比任何单个应用程序都更有效地管理线程。系统可以根据可用资源和当前系统条件动态扩展线程数量。另外，系统通常能够比你自己创建线程更快地开始运行您的任务。

尽管您可能认为为调度队列重写代码会很困难，但为编写调度队列编写代码通常比为线程编写代码更容易。编写代码的关键是设计独立并且能够异步运行的任务。但是，调度队列的优势在于可预测性。如果您有两项访问相同共享资源但在不同线程上运行的任务，则任一线程都可以先修改资源，并且您需要使用锁定以确保两个任务不会同时修改该资源。使用分派队列，您可以将两个任务添加到串行分派队列，以确保在任何给定时间只有一个任务修改了资源。这种基于队列的同步比锁更有效，因为在竞争和无争议的情况下，锁总是需要昂贵的内核陷阱，而派遣队列主要在应用程序的进程空间中工作，并且只在绝对必要时调用内核。

虽然你会正确地指出在串行队列中运行的两个任务不会同时运行，您必须记住，如果两个线程同时进行锁定，则线程提供的任何并发都会丢失或显着减少。更重要的是，线程模型需要创建两个线程，它们同时占用内核和用户空间内存。调度队列不会为它们的线程支付相同的内存损失，并且它们使用的线程保持繁忙并且不被阻塞。

有关调度队列的其他一些关键要点包括以下内容：

* 调度队列相对于其他调度队列同时执行其任务。任务序列化仅限于单个调度队列中的任务。
* 系统确定任何时候执行的任务总数。因此，100个不同队列中有100个任务的应用程序可能不会同时执行所有这些任务（除非它具有100个或更多有效内核）。

* 系统在选择要开始的新任务时考虑队列优先级。

* 队列中的任务在添加到队列时必须准备好执行。

* 私有调度队列是引用计数的对象。除了在自己的代码中保留队列之外，请注意，调度源也可以附加到队列中，并增加其保留计数。因此，您必须确保所有调度源都被取消，并且所有保留呼叫均通过适当的释放呼叫进行平衡。

### 与队列相关的技术

使用调度队列的技术：

* 调度组（Dispatch groups）

调度组是一种监视一组块对象以完成的方法。组为依赖于其他任务完成的代码提供有用的同步机制。

* 调度信号量（Dispatch semaphores）

调度信号与传统信号相似，但通常更高效。只有当调用线程需要被阻塞，因为信号量不可用时，调度信号才会调用内核。如果信号量可用，则不进行内核调用。

* 调度源（Dispatch sources）

调度源生成通知以响应特定类型的系统事件。您可以使用调度源来监视事件，例如进程通知，信号和描述符事件等。发生事件时，调度源将您的任务代码异步提交给指定的调度队列进行处理。

### 使用块实现任务

块对象是一种基于C语言的功能，可以在 C，Objective-C 和 C ++ 代码中使用。块可以很容易地定义一个独立的工作单元。虽然它们看起来可能类似于函数指针，但块实际上是由类似于对象的基础数据结构表示的，并且由编译器为您创建和管理。编译器将您提供的代码（以及任何相关数据）打包，并将其封装在可存放在堆中并可在应用程序中传递的表单中。

块的关键优势之一是它们能够使用自己词汇范围之外的变量。当你在一个函数或方法中定义一个块时，这个块在某些方面会起传统的代码块的作用。例如，块可以读取父范围中定义的变量的值。该块访问的变量被复制到堆上的块数据结构中，以便该块稍后可以访问它们。将块添加到分派队列时，这些值通常必须保留为只读格式。但是，同步执行的块也可以使用带有 \_\_block 关键字的变量，以便将数据返回到父级的调用作用域。

使用与用于函数指针的语法类似的语法，将代码块与代码一起声明。块和函数指针之间的主要区别在于块名前面有一个插入符号（^）而不是星号（\*）。就像函数指针一样，您可以将参数传递给块并从中接收返回值。

一个简单的块例子：

```
int x = 123;
int y = 456;
 
// Block declaration and assignment
void (^aBlock)(int) = ^(int z) {
    printf("%d %d %d\n", x, y, z);
};
 
// Execute the block
aBlock(789);   // prints: 123 456 789
```

以下是您在设计模块时应考虑的一些主要指导方针的总结：

* 对于您计划使用调度队列异步执行的块，从父函数或方法捕获标量变量并在块中使用它们是安全的。但是，您不应该尝试捕获调用上下文分配和删除的大型结构或其他基于指针的变量。当你的块被执行时，那个指针引用的内存可能会消失。当然，自己分配内存（或对象）是安全的，并明确地将该内存的所有权移交给该块。

* 调度队列复制添加到它们的块，并在完成执行时释放块。换句话说，在将块添加到队列之前，您不需要显式复制块。

* 尽管在执行小任务时队列比原始线程更有效，但在创建块并在队列上执行它们方面仍存在开销。如果一个块的功能太少，那么执行内联比将其派送到队列可能更便宜。判断块是否做得太少的方法是使用性能工具收集每条路径的指标并进行比较。

* 不要缓存相对于底层线程的数据，并期望可以从不同的块访问数据。如果同一队列中的任务需要共享数据，请使用调度队列的上下文指针来存储数据。

* 如果您的块创建了多个 Objective-C 对象，则可能需要将块的部分代码放在 @autorelease 块中以处理这些对象的内存管理。尽管 GCD 调度队列拥有自己的自动释放池，但他们无法保证这些池何时耗尽。如果您的应用程序受内存限制，则创建您自己的自动释放池可以让您以更常规的时间间隔为自动释放对象释放内存。

### 创建并管理调度队列

### 将任务添加到队列

### 暂停和恢复队列

### 使用调度信号来调节有限资源的使用

### 等待排队任务组



